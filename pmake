#!/usr/bin/env python
from __future__ import print_function
from subprocess import Popen, STDOUT
from threading import Thread
import atexit
import os
import sys
import termios
import json
import yaml

from gossi import Logger, Msg


LOGGER = Logger()

def which(file):
    for path in os.environ["PATH"].split(os.pathsep):
        if os.path.exists(os.path.join(path, file)):
                return os.path.join(path, file)

    return None

def enable_echo(enable):
    fd = sys.stdin.fileno()
    new = termios.tcgetattr(fd)
    if enable:
        new[3] |= termios.ECHO
    else:
        new[3] &= ~termios.ECHO

    termios.tcsetattr(fd, termios.TCSANOW, new)


def follow_directive(tag, root, build_directive):
    requirements = build_directive['require']
    build_opts = {}
    for req in requirements.keys():
        for opt in requirements[req]['opt']:
            if which(opt) != None:
                build_opts[req] = opt
                break
        if req not in build_opts.keys():
            LOGGER.log(Msg(tag, 'Failed - {err_msg}'.format(**build_directive), msg_color='red'), tag_id=tag)
            return

    for cmd in build_directive['run']:
        os.makedirs(os.path.dirname(build_directive['log_file']), exist_ok=True)
        with open(os.path.join('.', build_directive['log_file']), 'w+') as logfile:
            work_dir = '.' if 'path' not in build_directive.keys() else os.path.join(root, build_directive['path'])
            process = Popen(cmd['cmd'].format(**build_opts).split(), stderr=STDOUT, stdout=logfile, cwd=work_dir)
            LOGGER.wait(tag, Msg(tag, cmd['msg']), process)
            process.wait()
            if process.returncode != 0:
                err = 'Exited with nonzero code: {}'.format(process.returncode)
                LOGGER.log(Msg(tag, err, msg_color='red'), tag_id=tag)
                break
    LOGGER.log(Msg(tag, 'Done.', msg_color='green'), tag_id=tag)


def spawn(directive, tag, root):
    LOGGER.tag(tag).log(Msg(tag, 'Beginning build...'), tag_id=tag)
    t = Thread(target=follow_directive, args=[tag, root, directive])
    t.start()
    return t


def build(config):
    root = os.getcwd()

    LOGGER.log(Msg('system', 'Starting Build:'))
    LOGGER.log(Msg('system', '---------------'))

    build_groups = config['groups']
    directives = config['directives']

    # Run build groups in order
    for build_group in build_groups:

        awaiting = []

        # Launch all build group tasks
        for task in build_group:
            awaiting += [spawn(directives[task['directive']], task['tag'], root)]

        # Wait for all tasks to finish
        for process in awaiting:
            process.join()

    LOGGER.log(Msg('system', '---------------'))
    LOGGER.log(Msg('system', 'Build Completed.'))


# always run
atexit.register(enable_echo, True)
enable_echo(False)

# Run when main
if __name__ == '__main__':
    assert sys.version_info >= (3, 2), 'PMake requires Python > 3.2'
    args = {}
    if (os.path.exists('pmake.json')):
        with open(os.path.join(os.getcwd(), 'pmake.json')) as cfg:
            args = json.load(cfg.read())
            print('Loaded from JSON config file')
    elif (os.path.exists('pmake.yml')):
        with open(os.path.join(os.getcwd(), 'pmake.yml')) as cfg:
            args = yaml.load(cfg.read())
            print('Loaded from YAML config file')
    else:
        print('PMake config not found in local directory')
        sys.exit(1)
    build(args)
